<?php

/*
 * wordpress_vulnerabilities.php
 */

class wordpress_vulnerability_base_class
{
/*
{metadocument}
	<variable>
		<name>error</name>
		<type>STRING</type>
		<value></value>
		<documentation>
			<purpose>Store the message that is returned when an error
				occurs.</purpose>
			<usage>Check this variable to understand what happened when a call to
				any of the class functions has failed.<paragraphbreak />
				This class uses cumulative error handling. This means that if one
				class functions that may fail is called and this variable was
				already set to an error message due to a failure in a previous call
				to the same or other function, the function will also fail and does
				not do anything.<paragraphbreak />
				This allows programs using this class to safely call several
				functions that may fail and only check the failure condition after
				the last function call.<paragraphbreak />
				Just set this variable to an empty string to clear the error
				condition.</usage>
		</documentation>
	</variable>
{/metadocument}
*/
	var $error = '';

	var $name = '';

	var $wordpress_vulnerabilities;

	var $debug_prefix = 'WordPress vulnerability {name}: ';

	protected function SetError($error)
	{
		$this->error = $error;
		if($this->wordpress_vulnerabilities->debug)
			$this->wordpress_vulnerabilities->OutputDebug('Error: '.$error, str_replace('{name}', $this->name, $this->debug_prefix));
		return(false);
	}

	function Initialize($options)
	{
		return true;
	}

	function Finalize($success)
	{
		return $success;
	}
};

class wordpress_vulnerabilities_class
{
/*
{metadocument}
	<variable>
		<name>error</name>
		<type>STRING</type>
		<value></value>
		<documentation>
			<purpose>Store the message that is returned when an error
				occurs.</purpose>
			<usage>Check this variable to understand what happened when a call to
				any of the class functions has failed.<paragraphbreak />
				This class uses cumulative error handling. This means that if one
				class functions that may fail is called and this variable was
				already set to an error message due to a failure in a previous call
				to the same or other function, the function will also fail and does
				not do anything.<paragraphbreak />
				This allows programs using this class to safely call several
				functions that may fail and only check the failure condition after
				the last function call.<paragraphbreak />
				Just set this variable to an empty string to clear the error
				condition.</usage>
		</documentation>
	</variable>
{/metadocument}
*/
	var $error = '';

/*
{metadocument}
	<variable>
		<name>debug</name>
		<type>BOOLEAN</type>
		<value>0</value>
		<documentation>
			<purpose>Control whether debug output is enabled</purpose>
			<usage>Set this variable to <booleanvalue>1</booleanvalue> if you
				need to check what is going on during calls to the class. When
				enabled, the debug output goes either to the variable
				<variablelink>debug_output</variablelink> and the PHP error log.</usage>
		</documentation>
	</variable>
{/metadocument}
*/
	var $debug = true;

/*
{metadocument}
	<variable>
		<name>log_file_name</name>
		<type>STRING</type>
		<value></value>
		<documentation>
			<purpose>Name of the file to store log messages</purpose>
			<usage>Set this variable to the path of a file to which log messages
				will be appended instead of sending to PHP error log when the
				<variablelink>debug</variablelink> variable is set to
				<booleanvalue>1</booleanvalue>.</usage>
		</documentation>
	</variable>
{/metadocument}
*/
	var $log_file_name = '';

/*
{metadocument}
	<variable>
		<name>debug_output</name>
		<type>STRING</type>
		<value></value>
		<documentation>
			<purpose>Capture the debug output generated by the class</purpose>
			<usage>Inspect this variable if you need to see what happened during
				the class function calls.</usage>
		</documentation>
	</variable>
{/metadocument}
*/
	var $debug_output = '';

/*
{metadocument}
	<variable>
		<name>debug_prefix</name>
		<type>STRING</type>
		<value>OAuth client: </value>
		<documentation>
			<purpose>Mark the lines of the debug output to identify actions
				performed by this class.</purpose>
			<usage>Change this variable if you prefer the debug output lines to
				be prefixed with a different text.</usage>
		</documentation>
	</variable>
{/metadocument}
*/
	var $debug_prefix = 'WordPress vulnerabilities: ';

	var $options = array(
		'database_host' => 'localhost',
		'database_user' => '',
		'database_password' => '',
		'database_name' => 'wordpress',
		'database_port' => null,
		'database_socket' => null,
		'database_charset' => 'utf8',
		'vulnerability_options' => array()
	);

/*
{metadocument}
	<variable>
		<name>configuration_file</name>
		<type>STRING</type>
		<value>wordpress_vulnerabilities.json</value>
		<documentation>
			<purpose>Specify the path of the configuration file that
				defines details of each supported vulnerability check.</purpose>
			<usage>Change the path in this variable if you want to perform
				vulnerability checks defined in a different files.</usage>
		</documentation>
	</variable>
{/metadocument}
*/
	var $configuration_file = 'wordpress_vulnerabilities.json';

	private $configuration;
	private $loaded_vulnerability_objects = array();
	private $database;

	private function SetError($error)
	{
		$this->error = $error;
		if($this->debug)
			$this->OutputDebug('Error: '.$error);
		return(false);
	}

	function OutputDebug($message, $prefix = '')
	{
		if($this->debug)
		{
			if($prefix === $this->debug_prefix)
				$prefix = $this->debug_prefix;
			$message = $prefix.$message;
			$this->debug_output .= $message."\n";
			if(strlen($this->log_file_name))
				error_log($message."\n", 3, $this->log_file_name);
			else
				error_log($message);
		}
		return(true);
	}

	private function LoadConfigurationFile()
	{
		if(IsSet($this->configuration))
			return true;
		if(!($json = @file_get_contents($this->configuration_file)))
		{
			if(!file_exists($this->configuration_file))
				return $this->SetError('the WordPress vulnerabilities configuration file '.$this->configuration_file.' does not exist');
			return $this->SetPHPError('could not read the WordPress vulnerabilities configuration file '.$this->configuration_file);
		}
		$wordpress_vulnerabilities = json_decode($json);
		if(!IsSet($wordpress_vulnerabilities))
			return $this->SetPHPError('It was not possible to decode the WordPress vulnerabilities configuration file '.$this->configuration_file.' eventually due to incorrect format');
		if(GetType($wordpress_vulnerabilities) !== 'object')
			return $this->SetError('It was not possible to decode the WordPress vulnerabilities configuration file '.$this->configuration_file.' because it does not correctly define a JSON object');
		if(!IsSet($wordpress_vulnerabilities->vulnerabilities)
		|| GetType($wordpress_vulnerabilities->vulnerabilities) !== 'object')
			return $this->SetError('It was not possible to decode the WordPress vulnerabilities configuration file '.$this->configuration_file.' because it does not correctly define a JSON object for vulnerabilities');
		foreach($wordpress_vulnerabilities->vulnerabilities as $vulnerability => $properties)
		{
			if(!IsSet($wordpress_vulnerabilities->vulnerabilities->{$vulnerability}))
				return($this->SetError($vulnerability.' is not yet a supported type of WordPress vulnerabilities. Please send a request in this class support forum (preferred) http://www.phpclasses.org/oauth-api , or if it is a security or private matter, contact the author Manuel Lemos mlemos@acm.org to request adding built-in support to this type of WordPress vulnerabilities.'));
			if(GetType($properties) !== 'object')
				return $this->SetError('The WordPress vulnerabilities configuration file '.$this->configuration_file.' for the "'.$vulnerability.'" server does not correctly define a JSON object');
			$types = array(
				'class'=>'string',
				'files'=>'array',
			);
			$required = array(
				'class'=>array(),
				'files'=>array(),
			);
			$this->configuration = array();
			foreach($properties as $property => $value)
			{
				if(!IsSet($types[$property]))
					return $this->SetError($property.' is not a supported property for the "'.$vulnerability.'" server in the WordPress vulnerabilities configuration file '.$this->configuration_file);
				$type = GetType($value);
				$expected = $types[$property];
				if($type !== $expected)
					return $this->SetError(' the property "'.$property.'" for the "'.$vulnerability.'" server is not of type "'.$expected.'", it is of type "'.$type.'", in the WordPress vulnerabilities configuration file '.$this->configuration_file);
				$this->configuration[$vulnerability][$property] = $value;
				UnSet($required[$property]);
			}
			foreach($required as $property => $value)
			{
				if(count($value)
				&& in_array($this->oauth_version, $value))
					return $this->SetError('the property "'.$property.'" is not defined for the "'.$vulnerability.'" server in the WordPress vulnerabilities configuration file '.$this->configuration_file);
			}
		}
		return true;
	}

	private function LoadVulnerabilityObject($name, &$vulnerability)
	{
		if(IsSet($this->loaded_vulnerability_objects[$name]))
		{
			$vulnerability = $this->loaded_vulnerability_objects[$name];
			return true;
		}
		$configuration = $this->configuration[$name];
		foreach($configuration['files'] as $file)
		{
			if(!file_exists($file))
				return $this->SetError('the WordPress vulnerability class file "'.$file.'" does not seem to exist.');
			require_once($file);
		}
		$vulnerability = new $configuration['class'];
		if($vulnerability->name === '')
			$vulnerability->name = $name;
		$vulnerability->wordpress_vulnerabilities = $this;
		$options = array();
		if(!$vulnerability->Initialize($options))
		{
			return $this->SetError('Could not initialize the object to handle the vulnerability "'.$check.'" due to error: '.$Vulnerabilities->error);
		}
		$this->loaded_vulnerability_objects[$name] = $vulnerability;
		return true;
	}
	
	function ConnectToDatabase()
	{
		if(IsSet($this->database))
			return true;
		if($this->options['database_host'] === '')
			return $this->SetError('The database database configuration values were not set');
		$database = mysqli_connect($this->options['database_host'], $this->options['database_user'], $this->options['database_password'], $this->options['database_name'], $this->options['database_port'], $this->options['database_socket']);
		if(!$database)
			return $this->SetError('Could not connect to the database due to error: '.mysqli_connect_error());
		if(!mysqli_set_charset($database, $this->options['database_charset']))
		{
			$error = mysqli_error($this->database);
			mysqli_close($database);
			return $this->SetError('Could not set the database connection character set due to error: '.$error);
		}
		$this->database = $database;
		return true;
	}

	function DisconnectFromDatabase()
	{
		if(!IsSet($this->database))
			return true;
		if(!mysqli_close($this->database))
			return $this->SetError('Could not close the database connect due to error: '.mysqli_connect_error());
		$this->database = null;
		return true;
	}

	function GetAllQueryResults($query, &$results)
	{
		if(!$this->ConnectToDatabase())
			return false;
		if(!($result = mysqli_query($this->database, $query, MYSQLI_USE_RESULT)))
			return $this->SetError('Could not execute query "'.$query.'" due to error: '.mysqli_error($this->database));
		$results = mysqli_fetch_all($result);
		mysqli_free_result($result);
		return true;
	}

	function Query($query, &$results)
	{
		if(!$this->ConnectToDatabase())
			return false;
		if(!($result = mysqli_query($this->database, $query)))
			return $this->SetError('Could not execute query "'.$query.'" due to error: '.mysqli_error($this->database));
		$results = array();
		return true;
	}

	Function ProcessOptions(&$store, $options, $valid, $required, $context)
	{
		foreach($options as $name => $value)
		{
			if(!IsSet($valid[$name]))
				return $this->SetError('it was passed an invalid option named '.$name.' for the '.$context);
			$type = $valid[$name];
			$value_type = GetType($value);
			if($value_type !== $type)
				return $this->SetError('it was passed an option named '.$name.' of type '.$value_type.' when it was expected a value of type '.$type.' for the '.$context);
			$store[$name] = $value;
		}
		foreach($required as $name => $yes)
		{
			if($yes
			&& !IsSet($options[$name]))
				return $this->SetError('it was not passed the required option with name '.$name.' for the '.$context);
		}
		return true;
	}

	function Initialize($options)
	{
		$valid = array(
			'database_host'=>'string',
			'database_user'=>'string',
			'database_password'=>'string',
			'database_name'=>'string',
			'database_port'=>'integer',
			'database_socket'=>'string',
			'database_charset'=>'string',
			'vulnerability_options'=>'array',
		);
		$required = array(
			'database_user'=>true,
			'database_password'=>true,
		);
		return $this->ProcessOptions($this->options, $options, $valid, $required, 'WordPress vulnerability checking');
	}

	function Finalize($success)
	{
		foreach($this->loaded_vulnerability_objects as $name => $vulnerability)
		{
			if(!$vulnerability->Finalize($success))
			{
				if($success)
				{
					$success = false;
					$this->error = $vulnerability->error;
				}
			}
		}
		$this->loaded_vulnerability_objects = array();
		if(!$this->DisconnectFromDatabase())
			$success = false;
		return $success;
	}

	function GetSupportedVulnerabilityChecks(&$checks)
	{
		if(!$this->LoadConfigurationFile())
			return false;
		$checks = array_keys($this->configuration);
		return true;
	}

	function CheckVulnerability($name, &$vulnerable)
	{
		if(!$this->LoadConfigurationFile())
			return false;
		if(!IsSet($this->configuration[$name]))
			return $this->SetError($name.' is not a supported vulnerability name');
		if(!$this->LoadVulnerabilityObject($name, $vulnerability))
			return false;
		$options = (IsSet($this->options['vulnerability_options']['vulnerabilities'][$name]) ? $this->options['vulnerability_options']['vulnerabilities'][$name] : array());
		if($vulnerability->Check($options, $vulnerable))
			return true;
		if($this->error === '')
			$this->error = $vulnerability->error;
		return false;
	}

	function FixVulnerability($name, &$fixed)
	{
		$fixed = null;
		if(!$this->LoadConfigurationFile())
			return false;
		if(!IsSet($this->configuration[$name]))
			return $this->SetError($name.' is not a supported vulnerability name');
		if(!$this->LoadVulnerabilityObject($name, $vulnerability))
			return false;
		$options = (IsSet($this->options['vulnerability_options']['vulnerabilities'][$name]) ? $this->options['vulnerability_options']['vulnerabilities'][$name] : array());
		$plan = array();
		if($vulnerability->Fix($options, $plan))
		{
			if(count($plan) === 0)
				return $this->SetError('it was not returned a valid plan to fix the vulnerability '.$name);
			$fixed = array();
			foreach($plan as $step)
			{
				$valid = array(
					'Type'=>'string',
					'Details'=>'array',
				);
				$required = array(
					'Type'=>array(),
					'Details'=>array(),
				);
				if(!$this->ProcessOptions($step_values, $step, $valid, $required, $name.' WordPress vulnerability fixing plan'))
					return false;
				switch($step_values['Type'])
				{
					case 'update_query':
						$valid = array(
							'Table'=>'string',
							'Fields'=>'array',
							'Conditions'=>'array'
						);
						$required = array(
							'Table'=>array(),
							'Fields'=>array(),
							'Conditions'=>array()
						);
						if(!$this->ProcessOptions($details_values, $step_values['Details'], $valid, $required, $name.' WordPress vulnerability fixing plan database update query'))
							return false;
						$fields = '';
						foreach($details_values['Fields'] as $field => $value)
						{
							$type = GetType($value);
							switch($type)
							{
								case 'string':
									$value = "'".mysqli_real_escape_string($this->database, $value)."'";
									break;
								default:
									return $this->SetError($type.' is not yet a supported query field value for WordPress vulnerability '.$name);
							}
							$fields .= ($fields === '' ? ' ' : ', ').$field.' = '.$value;
						}
						$conditions = '';
						foreach($details_values['Conditions'] as $condition)
						{
							$valid = array(
								'Type'=>'string',
								'Details'=>'array',
							);
							$required = array(
								'Type'=>array(),
								'Details'=>array(),
							);
							if(!$this->ProcessOptions($condition_values, $condition, $valid, $required, $name.' WordPress vulnerability fixing plan database update query condition clause'))
								return false;
							$type = $condition_values['Type'];
							switch($type)
							{
								case 'equal':
									$details = $condition_values['Details'];
									if(IsSet($details['LeftField']))
										$left = $details['LeftField'];
									else
										return $this->SetError('it was not specified a query condition equal left side expression for WordPress vulnerability '.$name);
									if(IsSet($details['RightValue']))
									{
										$type = GetType($details['RightValue']);
										switch($type)
										{
											case 'string':
												$right = "'".mysqli_real_escape_string($this->database, $details['RightValue'])."'";
												break;
											case 'integer':
												$right = $details['RightValue'];
												break;
											default:
												return $this->SetError($type.' is not yet a supported query condition value for WordPress vulnerability '.$name);
										}
									}
									else
										return $this->SetError('it was not specified a query condition equal left side expression for WordPress vulnerability '.$name);
									$clause = $left.' = '.$right;
									break;
								default:
									return $this->SetError($type.' is not yet a supported query condition type for WordPress vulnerability '.$name);
							}
							$conditions .= ' '.$clause;
						}
						$sql = 'UPDATE'.' '.$details_values['Table'].' SET'.$fields.' WHERE'.$conditions;
						$fix = array(
							'Type'=>'query',
							'Details'=>array(
								'SQL'=>$sql
							)
						);
						break;
					default:
						return $this->SetError($step_values['Type'].' is not yet a supported fixing plan step type for vulnerability '.$name);
				}
				$fixed[] = $fix;
			}
			if(IsSet($this->options['vulnerability_options']['dry_run'])
			&& $this->options['vulnerability_options']['dry_run'])
				return true;
			$transaction = false;
			$success = true;
			foreach($fixed as $fix)
			{
				$type = $fix['Type'];
				switch($type)
				{
					case 'query':
						if(!$transaction)
						{
							if(!mysqli_begin_transaction($this->database, MYSQLI_TRANS_START_WITH_CONSISTENT_SNAPSHOT))
							{
								$success = $this->SetError('it was not possible to start a transaction before applying the fix for WordPress vulnerability '.$name.' due to error: '.mysqli_error($this->database));
								break 2;
							}
							$transaction = true;
						}
						if(!($success = $this->Query($fix['Details']['SQL'], $results)))
							break 2;
						break;
					default:
						$success = $this->SetError($type.' is not yet a supported type of fix for WordPress vulnerability '.$name);
						break 2;
				}
			}
			if($transaction)
			{
				if(mysqli_commit($this->database))
					$transaction = false;
				else
					$success = $this->SetError('it was not possible to finish a transaction after applying the fix for WordPress vulnerability '.$name.' due to error: '.mysqli_error($this->database));
			}
			return $success;
		}
		if($this->error === '')
			$this->error = $vulnerability->error;
		return false;
	}
};

